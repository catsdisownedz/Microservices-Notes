
----------
## Notes and Summary

Images in Docker are the blueprints of the application which form the basis of the application.
- `(docker pull)`
Containers are created from the images and run the actual images in an isolated space to protect disk space on the desktop.
- `(docker run)`
We can see the list of running containers using:
- `(docker ps)`
They include all the things needed to run the app such as Node.js or MongoDB.

**Docker Daemon:**
The lower priority background service running on the host that manages building, running, and distributing Docker containers.

**Docker Client:**
A command line tool that allows users to interact with Docker. Kitematic can provide a GUI for the user.

**Docker Hub:**
A directory for all available images. You can create your own Docker registry and use it for pulling images.

On one physical machine, we can have more than one virtual machine using a tool called a hypervisor like VirtualBox or Hyper-V.

The difference between containers and virtual machines is that VMs need a full-blown operating system, but containers more or less do the same function of isolating the apps to run except they're more lightweight and use the OS of the host. Containers don't need as many CPU resources, RAM, or disk space, which means we can run tens or hundreds of containers side by side.

Most things aren't cross-platform because the way that each OS interacts with the kernel of the machine is different (different APIs).

We usually use `node:alpine` when it is a small image.


Linux has many distributions (distros)
Ubuntu (the most popular distro)
Debian 
Alpine
Fedora
CentOS

- `docker run -it ubuntu` 
we use this to reach the container's shell, which is an interactive terminal session inside a new container based on the Ubuntu image that takes the commands and passes them to the OS for execution. we can leave this shell using `exit`. In conclusion allows you to work with the ubuntu shell without the need for a separate Ubuntu installation or VM.

#### Some revision over Linux commands
-  root@50938a15a31f:/#
	***root*:** is the user, and it means i am the highest privilege user.
	***after* (@) :** the name of the machine that's automatically generated by docker 
	***after* (:) :**  / means root directory, # means i have highest privileges. if i was logged in as a normal user it would be a $ sign 

- `echo $0` will see the location of the shell program 
- in windows we use \ as opposed to Linux where we use /

we can use `history` command to retrieve the list of the last commands we used + use !3 or !1 to execute the commands in those places 

we should always update your packages using `apt update` before installing a new package just in case 


`cd ~`  takes us to the home directory 
`rm -r` aka recursive to remove the directory with all its contents 
`more` differs than `cat` because its better to display bigger files. and it allows the user to click "display more"
`less` to view the contents of the file in an interactive way 
`head` can display a specific number of lines from the top of the file 
`tail` same thing but from the bottom 

### Docker compose 

- Front end (ex: built with react.js)
- Back end (ex: built with node)
- Database (ex: mongoDb)

`docker container ls -a   `    # List all containers
`docker container rm $(docker container ls -a -q)`  # Remove all containers
`docker image rm $(docker image ls -q)  ` # Remove all images

if i still encounter errors i might need to force removal of images using `-f` (especially if the container is still running)

`docker-compose up --build`  to run and build the container in one go, and make sure to maintain the updates 

`docker compose down` to stop the container

Generally YAML is slower than JSON because it considers everything as a string then evaluates later, meanwhile json is clearer in its datatypes.

- Front end must have a different port from the Back end therefore we must repeat the dockerfiles for each of them (up to us to change what we need but changing the ports is necessary)
- to ping the container we use `docker exec -it (container ID)`, we usually need to be root users in order to ping 
- therefore we use `docker exec -it -u root (container ID)` to login as root user
- `ipconfig`to find the IP address of the container
- All containers have ip addresses within the same network 
## Resources

### Tutorials

- [Docker Documentation](https://docs.docker.com/guides/workshop/)
- [Docker Curriculum](https://docker-curriculum.com/)
- [Guide](https://docs.docker.com/guides/workshop/02_our_app/)
- [Docker compose getting started](https://docs.docker.com/compose/gettingstarted/)
- [How compose works](https://docs.docker.com/compose/compose-application-model/)
- [Docker with java](https://www.geeksforgeeks.org/how-to-create-a-java-docker-container/)

### Books

- [Nothing here yet](https://example.com)

### YouTube

- [Docker Tutorial for Beginners](https://www.youtube.com/watch?v=pTFZFxd4hOI)
- [Docker Compose](https://www.youtube.com/watch?v=HG6yIjZapSA)
- [Compose Networking](https://www.youtube.com/watch?v=bKFMS5C4CG0)
